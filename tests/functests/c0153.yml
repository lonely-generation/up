doc_meta: |
  folder: user-interaction
  title: chained pipein from stdin
  head: |
    You can use UPcmd to chain the command output as input and choose a task to handle the data processing

  sections:
    - title: concept
      content: |
        So far, we can use an instanceid as context id to select what set of configuration we want to use, nomally they are categorized by global configuration, environment group configuration and individual context instance, for example as below:

        ```
        global\_
                |_nonprod
                    |_dev
                    |_staging
                |_prod
                    |_prod
        ```

        You could use [ up ngo mytask -i dev ] to do deployment work aginst dev environment

        However these configuration are more like server (backend) configuration. Most of time, we will have some other configurations, they are related to pipeline user input, for example:

        * username
        * password(secured)
        * flags for build/deployment/workflow to behave differently, eg,
            * create db everytime or skip
            * a resource id (ec2-instanceid/iam-profile-id/database name etc) as data injection for the workflow
        * temporary config entry for manual test

        All these settings are more like a user execution profile rather static and stable server environment configuration

        In this case we could classify them all together into an execution profile, for example

        ```
        global\_
                |_nonprod
                    |_dev
                         \_dev1_test
                              ...
                         \_dev2_test:
                              ...
                         \_dev1_use_memcache:
                              |_ ENV var1
                              |_ ENV var2
                              |_ ENV var3
                              |_ vars:
                              |_ dvars:
                         \_dev2_no_db_recreat
                              ....
                    |_staging
                |_prod
                    |_prod
        ```

        By using such a execution profile, the CI/CD tools does not need to handle the multiple environment variable entries and secure variable entries, all these could be handled by UPcmd. To trigger the pipeline, a code push is all needed.

        This turns the audit to a precise git commit history so it is tracable to understand whose code has actually cause the problem, as the most of current CI/CD tools in the market, they are lack(weak) of this type of tracability

    - title: Explain
      content: |
        Please note the execution profile extend dev instance, see the differences of the final var merged

        ```
        up ngo task -d ./tests/functests -t c0153 -p dev1_use_memcache --configdir=./tests/functests
        ```

        ```
        1: inspect[exec_vars](*core.Cache)({
          "skip_create_rds": "True",
          "db_user": "test_db_user",
          "db_url": "jdbc:postgres://dev.myapp.com:8354/test?user=test_db_user&password=6HmsmiJIW1PfIXcF4WwOKOMDiL7PstgfKs2aRFajrwY=&ssl=true",
          "db_host": "memcache.local.host",
          "db_hostname": "dev.myapp.com",
          "host_alias": "dev",
          "db_port": 8354,
          "port": 5432,
          "deploy_user": "tomhanks",
          "db_password": "6HmsmiJIW1PfIXcF4WwOKOMDiL7PstgfKs2aRFajrwY=",
          "db_driver": "postgres"
        })
        ```

        ```
        up ngo task -d ./tests/functests -t -id dev c0153 --configdir=./tests/functests
        ```

        ```
        1: inspect[exec_vars](*core.Cache)({
          "db_driver": "postgres",
          "db_url": "jdbc:postgres://dev.myapp.com:8354/test?user=test_db_user&password=6HmsmiJIW1PfIXcF4WwOKOMDiL7PstgfKs2aRFajrwY=&ssl=true",
          "db_user": "test_db_user",
          "db_hostname": "dev.myapp.com",
          "db_password": "6HmsmiJIW1PfIXcF4WwOKOMDiL7PstgfKs2aRFajrwY=",
          "db_port": 8354,
          "host_alias": "dev",
          "port": 5432,
          "db_host": "nonpord_database.test.host"
        })

        ```

notes:
  - add feature of execution profile

scopes:
  - name: global
    vars:
      db_driver: postgres
      port: 5432

  - name: nonprod
    members:
      - dev
      - staging
    vars:
      db_host: nonpord_database.test.host
      db_port: 8354
      db_user: test_db_user
      db_password: could_be_encrypted_using_upcmd_too
    dvars:
      - name: db_password
        value: '6HmsmiJIW1PfIXcF4WwOKOMDiL7PstgfKs2aRFajrwY='

  - name: prod
    members: [prod]
    vars:
      host_alias: prod

  - name: dev
    vars:
      host_alias: dev

  - name: staging
    vars:
      host_alias: staging

  - name: prod
    vars:
      host_alias: prod
      db_host: pord_database.proddb.host
      db_user: prod_db_user
    dvars:
      - name: db_password
        value: 'prod_encrypte_aes'

dvars:
  - name: db_hostname
    value: '{{.host_alias}}.myapp.com'
  - name: db_url
    value: 'jdbc:{{.db_driver}}://{{.db_hostname}}:{{.db_port}}/test?user={{.db_user}}&password={{.db_password}}&ssl=true'

eprofiles:
  - name: dev1_use_memcache
    instance: dev
    vars:
      db_host: memcache.local.host
    dvars:
      - name: deploy_user
        value: tomhanks
      - name: skip_create_rds
        value: '{{ env "SKIP_CREATE_RDS" |default "True" }}'

tasks:
  -
    name: task
    task:

      -
        func: cmd
        do:
          - name: inspect
            cmd:
              - exec_vars
#          -
#            name: assert
#            cmd:
#              - '{{eq .a "caller-aaa"}}'
#              - '{{eq .b "module-bbb"}}'
